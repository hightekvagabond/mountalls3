#!/usr/bin/bash

# =============================================================================
# MountAllS3 Bucket Groups Setup
# =============================================================================
#
# DESCRIPTION:
#   Manages S3 bucket organization into logical groups for easy mounting.
#   Supports interactive bucket assignment, pattern matching, and group creation.
#
# FEATURES:
#   - Create and manage bucket groups
#   - Assign buckets to groups by profile
#   - Pattern-based bucket matching for automation
#   - Configure default mount groups
#
# =============================================================================

# Load common functions
COMMON_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$COMMON_SCRIPT_DIR/common.sh" || {
    echo "‚ùå Error: Could not load common.sh library"
    exit 1
}

# Creates bucket groups either interactively or from comma-separated list
# Validates group names and creates JSON configuration with default structure
configure_bucket_groups() {
    local specified_groups="$1"
    
    print_header "Bucket Group Creation"
    
    local group_names=()
    
    if [[ -n "$specified_groups" ]]; then
        # Non-interactive mode: parse comma-separated groups
        IFS=',' read -ra group_names <<< "$specified_groups"
        print_info "Creating specified groups: ${group_names[*]}"
        
        # Validate all group names
        for group in "${group_names[@]}"; do
            if ! validate_group_name "$group"; then
                print_error "Invalid group name: $group"
                return 1
            fi
        done
    else
        # Interactive mode
        echo "Bucket groups help organize your S3 buckets into logical collections."
        echo "Examples: 'user-folders', 'project1-buckets', 'infra-buckets', 'websites'"
        echo ""
        echo "üí° Don't worry about thinking of everything now - you can create new groups"
        echo "   on-the-fly when assigning buckets to them later!"
        echo ""
        echo "Enter the names of bucket groups you want to create (one per line)."
        echo "Press Enter on an empty line when done (or just press Enter to skip for now):"
        echo ""
        
        while true; do
            local group_name
            group_name=$(prompt_user "Group name" "")
            if [[ -z "$group_name" ]]; then
                break
            fi
            
            # Validate group name
            if validate_group_name "$group_name"; then
                group_names+=("$group_name")
                echo "  ‚úì Added group: $group_name"
            fi
        done
    fi
    
    if [[ ${#group_names[@]} -eq 0 ]]; then
        print_info "No groups created now - that's perfectly fine!"
        print_info "You can create groups later when assigning buckets."
        return 0
    fi
    
    # Create basic config with groups
    ensure_config_dir
    create_groups_config "${group_names[@]}"
    
    print_success "Created ${#group_names[@]} bucket groups"
    print_info "Next: Assign buckets to groups or configure AWS profiles"
}

# Generates complete JSON configuration file with specified groups
# Creates proper JSON structure with defaults and empty bucket arrays
create_groups_config() {
    local groups=("$@")
    local default_mount
    default_mount=$(get_default_mount_base)
    default_mount="${default_mount/#\~/$HOME}"
    
    # Create JSON structure
    local groups_json="{"
    for i in "${!groups[@]}"; do
        local group="${groups[$i]}"
        local desc="S3 buckets for $group"
        
        if [[ $i -gt 0 ]]; then
            groups_json+=","
        fi
        groups_json+="\"$group\": {\"description\": \"$desc\", \"buckets\": [], \"patterns\": []}"
    done
    groups_json+="}"
    
    # Create the complete JSON configuration
    cat > "$CONFIG_FILE" << EOF
{
  "_comment": "MountAllS3 Configuration - Generated by interactive setup on $(date)",
  "defaults": {
    "mount_groups": ["${groups[0]}"],
    "mount_base": "$default_mount",
    "aws_profile": "all"
  },
  "groups": $groups_json
}
EOF
    
    debug_debug "Created JSON config file with ${#groups[@]} groups"
    print_success "Configuration file created with ${#groups[@]} groups"
}

# Interactive wizard for assigning S3 buckets to groups by profile
# Allows bulk assignment or individual bucket selection per profile
assign_buckets_to_groups() {
    print_header "Bucket Assignment"
    
    if ! config_file_exists; then
        print_error "No configuration file found. Please create groups first."
        return 1
    fi
    
    # Get available groups
    local groups
    mapfile -t groups < <(get_config_groups)
    
    if [[ ${#groups[@]} -eq 0 ]]; then
        print_info "No groups found in configuration - you can create them as you go!"
        groups=()  # Start with empty array
    fi
    
    # Get AWS profiles
    local profiles
    mapfile -t profiles < <(get_aws_profiles)
    
    if [[ ${#profiles[@]} -eq 0 ]]; then
        print_error "No AWS profiles found"
        return 1
    fi
    
    print_info "Found ${#groups[@]} groups and ${#profiles[@]} AWS profiles"
    echo ""
    echo "Available groups:"
    for group in "${groups[@]}"; do
        echo "  ‚Ä¢ $group"
    done
    echo ""
    
    # Process each profile and let user assign buckets
    for profile in "${profiles[@]}"; do
        echo ""
        print_info "üîß Processing profile: $profile"
        
        # Get buckets for this profile
        local buckets
        mapfile -t buckets < <(get_buckets_for_profile "$profile")
        
        if [[ ${#buckets[@]} -eq 0 ]]; then
            print_warning "No accessible buckets found for profile '$profile'"
            continue
        fi
        
        echo "Found ${#buckets[@]} buckets in profile '$profile':"
        for i in "${!buckets[@]}"; do
            printf "  %2d. %s\n" $((i+1)) "${buckets[$i]}"
        done
        echo ""
        
        # Ask user what they want to do
        echo "What would you like to do?"
        if [[ ${#groups[@]} -gt 0 ]]; then
            echo "a. Add buckets to a group, current groups are:"
            for i in "${!groups[@]}"; do
                printf "     %d. %s\n" $((i+1)) "${groups[$i]}"
            done
            echo "     n. Create new group"
            echo "s. Skip this profile"
            echo ""
            
            local choice
            choice=$(prompt_user "Choose action (a <group#>, a n, or s)" "s")
        else
            echo "n. Create new group (no groups exist yet)"
            echo "s. Skip this profile"
            echo ""
            
            local choice
            choice=$(prompt_user "Choose action (n or s)" "s")
        fi
        
        case "$choice" in
            s|S|skip|Skip)
                print_info "Skipping profile '$profile'"
                continue
                ;;
            a\ [1-9]*|a[1-9]*)
                # Parse "a 1", "a1", etc. (only valid when groups exist)
                if [[ ${#groups[@]} -eq 0 ]]; then
                    print_warning "No groups exist yet. Use 'n' to create a new group."
                    continue
                fi
                
                local group_num
                if [[ "$choice" =~ ^a\ ([0-9]+)$ ]]; then
                    group_num="${BASH_REMATCH[1]}"
                elif [[ "$choice" =~ ^a([0-9]+)$ ]]; then
                    group_num="${BASH_REMATCH[1]}"
                else
                    print_warning "Invalid format. Use 'a 1' or 'a1'"
                    continue
                fi
                
                if [[ $group_num -ge 1 && $group_num -le ${#groups[@]} ]]; then
                    local selected_group="${groups[$((group_num-1))]}"
                    assign_to_selected_group "$profile" "$selected_group" "${buckets[@]}"
                else
                    print_warning "Invalid group number. Choose 1-${#groups[@]}"
                fi
                ;;
            a\ n|an|a\ N|aN|n|N)
                # Create new group (handles both "a n" and just "n")
                create_new_group_and_assign "$profile" "${buckets[@]}"
                # Reload groups list for subsequent profiles
                mapfile -t groups < <(get_config_groups)
                ;;
            *)
                if [[ ${#groups[@]} -gt 0 ]]; then
                    print_warning "Invalid choice. Use 'a <group#>', 'a n', or 's'"
                else
                    print_warning "Invalid choice. Use 'n' to create a new group or 's' to skip"
                fi
                ;;
        esac
    done
    
    print_success "Bucket assignment completed!"
    print_info "You can view your configuration with: ./setup-mountalls3.sh --show-config"
}

# Lists all accessible S3 buckets organized by AWS profile
# Useful for reviewing what buckets are available before assignment
list_buckets_for_profiles() {
    print_header "AWS Profile Bucket Listing"
    
    local profiles
    mapfile -t profiles < <(get_aws_profiles)
    
    if [[ ${#profiles[@]} -eq 0 ]]; then
        print_error "No AWS profiles found"
        return 1
    fi
    
    for profile in "${profiles[@]}"; do
        echo ""
        print_step "Buckets for profile: $profile"
        
        local buckets
        mapfile -t buckets < <(get_buckets_for_profile "$profile" 2>/dev/null)
        
        if [[ ${#buckets[@]} -gt 0 ]]; then
            for bucket in "${buckets[@]}"; do
                echo "  ‚Ä¢ $bucket"
            done
        else
            print_warning "No accessible buckets found for profile '$profile'"
        fi
    done
}

# Main interactive setup function for bucket groups
# Orchestrates group creation and optional bucket assignment
interactive_setup() {
    print_header "Bucket Groups Interactive Setup"
    
    if ! command -v aws >/dev/null 2>&1; then
        print_error "AWS CLI not found. Please install it first:"
        echo "  Ubuntu/Debian: sudo apt-get install awscli"
        echo "  macOS: brew install awscli"
        echo "  Or use pip: pip install awscli"
        return 1
    fi
    
    echo "This will help you create logical groups for your S3 buckets."
    echo ""
    
    # Step 1: Create groups
    configure_bucket_groups
    
    # Step 2: Optional bucket assignment
    echo ""
    if prompt_yes_no "Would you like to assign buckets to your groups now?" "y"; then
        assign_buckets_to_groups
        
        # Step 3: Configure default mount groups (only if groups exist and have buckets)
        echo ""
        local groups
        mapfile -t groups < <(get_config_groups)
        if [[ ${#groups[@]} -gt 0 ]]; then
            if prompt_yes_no "Would you like to configure which groups are mounted by default?" "y"; then
                configure_default_mount_groups
            else
                print_info "You can configure default groups later with: ./setup-mountalls3.sh --config --interactive"
            fi
        fi
    else
        print_info "You can assign buckets later with: ./setup-mountalls3.sh --assign-buckets"
    fi
    
    print_success "Group setup completed!"
}

# Displays help information for the bucket groups setup script
# Shows all available options and usage examples
show_usage() {
    echo "MountAllS3 Bucket Groups Setup"
    echo ""
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "GROUP MANAGEMENT:"
    echo "  --groups [GROUP1,GROUP2]   Configure bucket groups (interactive if no groups)"
    echo "  --assign-buckets           Assign buckets to groups (with pattern matching)"
    echo "  --list-buckets             List buckets for profiles"
    echo "  --default-groups           Configure which groups mount by default"
    echo "  --interactive              Run interactive group setup"
    echo ""
    echo "HELP:"
    echo "  --help, -h                 Show this help message"
    echo ""
    echo "BUCKET ASSIGNMENT WORKFLOW:"
    echo "  1. Shows all buckets in profile with numbers"
    echo "  2. Choose action: 'a <group#>' to add to existing group, 'a n' for new group"
    echo "  3. Choose assignment method: all buckets, pattern matching, or specific numbers"
    echo ""
    echo "ASSIGNMENT METHODS:"
    echo "  ‚Ä¢ All current buckets: assign all buckets from the current profile"
    echo "  ‚Ä¢ Pattern matching: assign buckets containing text patterns (supports '*' wildcard)"
    echo "  ‚Ä¢ Specific selection: choose UNASSIGNED buckets by numbers (supports ranges like '1-5')"
    echo "  ‚Ä¢ Create new group: create groups on-the-fly during bucket assignment"
    echo ""
    echo "PATTERN EXAMPLES:"
    echo "  '*' ‚Üí matches ALL buckets in the profile (wildcard)"
    echo "  '.com' ‚Üí matches domain buckets (bigvision.com, mysite.com)"
    echo "  'dev' ‚Üí matches development buckets (myapp-dev, dev-staging)"
    echo "  'backup' ‚Üí matches backup buckets (daily-backup, user-backups)"
    echo ""
    echo "EXAMPLES:"
    echo "  $0 --groups user-folders,websites,infra    # Create groups non-interactively"
    echo "  $0 --groups                                # Create groups interactively"
    echo "  $0 --assign-buckets                        # Assign buckets with pattern matching"
    echo "  $0 --default-groups                        # Configure default mount groups"
    echo "  $0 --list-buckets                          # List all available buckets"
}

# Main function with simple argument parsing for bucket group operations
# Routes to appropriate functions based on command line arguments
main() {
    case "${1:-}" in
        --help|-h)
            show_usage
            ;;
        --groups)
            shift
            configure_bucket_groups "$1"
            ;;
        --assign-buckets)
            assign_buckets_to_groups
            ;;
        --list-buckets)
            list_buckets_for_profiles
            ;;
        --default-groups)
            configure_default_mount_groups
            ;;
        --interactive)
            interactive_setup
            ;;
        "")
            interactive_setup
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
}

# =============================================================================
# DEFAULT MOUNT GROUPS CONFIGURATION
# =============================================================================

# Configures which groups should be mounted by default
# Allows user to select from available groups
configure_default_mount_groups() {
    print_header "Configure Default Mount Groups"
    echo ""
    
    # Get available groups
    local groups
    mapfile -t groups < <(get_config_groups)
    
    if [[ ${#groups[@]} -eq 0 ]]; then
        print_info "No groups available. Default mount groups will be empty."
        update_config_value "defaults.mount_groups" "[]"
        return 0
    fi
    
    echo "Available groups:"
    for i in "${!groups[@]}"; do
        local group="${groups[$i]}"
        local description=$(get_group_description "$group")
        printf "  %d. %s - %s\n" $((i+1)) "$group" "$description"
    done
    echo ""
    
    echo "Which groups should be mounted by default when you run 'mountalls3'?"
    echo "You can select multiple groups or none at all."
    echo ""
    
    if [[ ${#groups[@]} -eq 1 ]]; then
        # Only one group available
        if prompt_yes_no "Use '${groups[0]}' as default group?" "y"; then
            update_config_value "defaults.mount_groups" "[\"${groups[0]}\"]"
            print_success "‚úÖ Default group set to: ${groups[0]}"
        else
            update_config_value "defaults.mount_groups" "[]"
            print_info "No default groups configured. You'll need to specify groups manually."
        fi
    else
        # Multiple groups available
        echo "Enter group numbers separated by spaces (e.g., '1 3' for groups 1 and 3)"
        echo "Or press Enter to skip (no default groups)"
        echo ""
        
        local selection
        selection=$(prompt_user "Group numbers" "")
        
        if [[ -z "$selection" ]]; then
            update_config_value "defaults.mount_groups" "[]"
            print_info "No default groups configured. You'll need to specify groups manually."
        else
            # Parse selection and build JSON array
            local selected_groups=()
            for num in $selection; do
                if [[ "$num" =~ ^[0-9]+$ ]] && [[ $num -ge 1 && $num -le ${#groups[@]} ]]; then
                    selected_groups+=("${groups[$((num-1))]}")
                fi
            done
            
            if [[ ${#selected_groups[@]} -gt 0 ]]; then
                # Build JSON array
                local groups_json="["
                for i in "${!selected_groups[@]}"; do
                    if [[ $i -gt 0 ]]; then
                        groups_json+=", "
                    fi
                    groups_json+="\"${selected_groups[$i]}\""
                done
                groups_json+="]"
                
                update_config_value "defaults.mount_groups" "$groups_json"
                print_success "‚úÖ Default groups set to: ${selected_groups[*]}"
            else
                print_warning "No valid selection. No default groups configured."
                update_config_value "defaults.mount_groups" "[]"
            fi
        fi
    fi
    
    echo ""
    print_info "üí° You can always override defaults with:"
    print_info "   mountalls3 -g group1,group2    # Mount specific groups"
    print_info "   mountalls3 -a                  # Mount all buckets"
}

# =============================================================================
# HELPER FUNCTIONS FOR BUCKET ASSIGNMENT
# =============================================================================

# Assigns buckets using pattern matching for new group creation
# Supports multiple patterns and pattern rule saving
assign_buckets_by_pattern_new_group() {
    local new_group_name="$1"
    local profile="$2"
    shift 2
    local buckets=("$@")
    
    print_info "Pattern-based assignment for '$new_group_name'"
    echo ""
    echo "Enter patterns to match buckets for assignment to '$new_group_name':"
    echo "Examples: '*' (all buckets), '.com', 'dev', 'backup', 'training'"
    echo ""
    
    local assigned_buckets=()
    local remaining_buckets=("${buckets[@]}")
    
    while [[ ${#remaining_buckets[@]} -gt 0 ]]; do
        echo "Remaining buckets: ${#remaining_buckets[@]}"
        
        local pattern
        pattern=$(prompt_user "Enter pattern to match (or 'done' to finish)" "done")
        
        if [[ "$pattern" == "done" || -z "$pattern" ]]; then
            break
        fi
        
        # Find matching buckets
        local matching_buckets=()
        for bucket in "${remaining_buckets[@]}"; do
            if [[ "$pattern" == "*" ]] || [[ "$bucket" == *"$pattern"* ]]; then
                matching_buckets+=("$bucket")
            fi
        done
        
        if [[ ${#matching_buckets[@]} -eq 0 ]]; then
            print_warning "No buckets match pattern '$pattern'"
            continue
        fi
        
        echo "Found ${#matching_buckets[@]} buckets matching '$pattern':"
        for bucket in "${matching_buckets[@]}"; do
            echo "  ‚Ä¢ $bucket"
        done
        
        if prompt_yes_no "Save pattern rule for '$pattern' in '$new_group_name'?" "y"; then
            local pattern_desc="Buckets containing '$pattern' in profile '$profile'"
            add_pattern_to_group "$new_group_name" "$profile" "$pattern" "$pattern_desc"
            print_success "‚ú® Saved pattern rule: '$pattern' ‚Üí '$new_group_name'"
            
            # Track assigned buckets and remove from remaining
            for bucket in "${matching_buckets[@]}"; do
                assigned_buckets+=("$bucket")
            done
            
            local new_remaining=()
            for bucket in "${remaining_buckets[@]}"; do
                local is_matched=false
                for matched in "${matching_buckets[@]}"; do
                    if [[ "$bucket" == "$matched" ]]; then
                        is_matched=true
                        break
                    fi
                done
                if [[ "$is_matched" == false ]]; then
                    new_remaining+=("$bucket")
                fi
            done
            remaining_buckets=("${new_remaining[@]}")
        else
            # Just add current matching buckets
            for bucket in "${matching_buckets[@]}"; do
                add_bucket_to_group "$new_group_name" "$profile" "$bucket"
                print_success "‚úì Added: $bucket"
                assigned_buckets+=("$bucket")
            done
            
            # Remove from remaining list
            local new_remaining=()
            for bucket in "${remaining_buckets[@]}"; do
                local is_matched=false
                for matched in "${matching_buckets[@]}"; do
                    if [[ "$bucket" == "$matched" ]]; then
                        is_matched=true
                        break
                    fi
                done
                if [[ "$is_matched" == false ]]; then
                    new_remaining+=("$bucket")
                fi
            done
            remaining_buckets=("${new_remaining[@]}")
        fi
    done
}

# Assigns all buckets from a profile to a new group
# Simple bulk assignment with progress feedback
assign_all_buckets_new_group() {
    local new_group_name="$1"
    local profile="$2"
    shift 2
    local buckets=("$@")
    
    print_info "Assigning all ${#buckets[@]} buckets to group '$new_group_name'"
    local assigned_count=0
    for bucket in "${buckets[@]}"; do
        add_bucket_to_group "$new_group_name" "$profile" "$bucket"
        echo "  ‚úì Added: $bucket"
        ((assigned_count++))
    done
    print_success "Assigned $assigned_count buckets to '$new_group_name'"
}

# Individual bucket selection for new group creation
# Prompts yes/no for each bucket individually
assign_individual_buckets_new_group() {
    local new_group_name="$1"
    local profile="$2"
    shift 2
    local buckets=("$@")
    
    print_info "Select individual buckets for '$new_group_name'"
    echo ""
    
    for bucket in "${buckets[@]}"; do
        if prompt_yes_no "Add '$bucket' to '$new_group_name'?" "n"; then
            add_bucket_to_group "$new_group_name" "$profile" "$bucket"
            print_success "‚úì Added: $bucket"
        fi
    done
}

# Gets list of buckets from a profile that are not assigned to any group
# Returns only unassigned buckets for cleaner individual selection
get_unassigned_buckets() {
    local profile="$1"
    shift
    local all_buckets=("$@")
    
    if [[ ${#all_buckets[@]} -eq 0 ]]; then
        return 0
    fi
    
    local unassigned_buckets=()
    
    # Get all assigned buckets from all groups
    local assigned_buckets=()
    if config_file_exists; then
        local groups
        mapfile -t groups < <(get_config_groups)
        
        for group in "${groups[@]}"; do
            local group_buckets
            mapfile -t group_buckets < <(get_group_buckets "$group")
            
            for group_bucket in "${group_buckets[@]}"; do
                # Parse "profile:bucket" format
                if [[ "$group_bucket" == "$profile:"* ]]; then
                    local bucket="${group_bucket#*:}"
                    assigned_buckets+=("$bucket")
                fi
            done
        done
    fi
    
    # Filter out assigned buckets
    for bucket in "${all_buckets[@]}"; do
        local is_assigned=false
        for assigned in "${assigned_buckets[@]}"; do
            if [[ "$bucket" == "$assigned" ]]; then
                is_assigned=true
                break
            fi
        done
        if [[ "$is_assigned" == false ]]; then
            unassigned_buckets+=("$bucket")
        fi
    done
    
    # Output unassigned buckets
    printf '%s\n' "${unassigned_buckets[@]}"
}

# Assigns buckets to a selected group with multiple assignment options
# Offers all current buckets, pattern matching, or individual selection
assign_to_selected_group() {
    local profile="$1"
    local selected_group="$2"
    shift 2
    local buckets=("$@")
    
    print_header "Add Buckets to Group: $selected_group"
    echo ""
    echo "How would you like to add buckets from profile '$profile' to group '$selected_group'?"
    echo "  1. Add all ${#buckets[@]} current buckets"
    echo "  2. Add buckets by pattern (e.g., '.com', 'dev', '*' for all)"
    echo "  3. Add specific buckets (select by numbers from the list above)"
    echo ""
    
    local assignment_choice
    assignment_choice=$(prompt_user "Choose assignment method (1-3)" "1")
    
    case "$assignment_choice" in
        1)
            # Add all current buckets
            print_info "Adding all ${#buckets[@]} buckets to group '$selected_group'"
            local added_count=0
            for bucket in "${buckets[@]}"; do
                add_bucket_to_group "$selected_group" "$profile" "$bucket"
                echo "  ‚úì Added: $bucket"
                ((added_count++))
            done
            print_success "Added $added_count buckets to '$selected_group'"
            ;;
        2)
            # Pattern-based assignment
            print_info "Pattern-based assignment to '$selected_group'"
            echo ""
            echo "Enter patterns to match buckets:"
            echo "Examples: '*' (all buckets), '.com', 'dev', 'backup', 'training'"
            echo ""
            
            local remaining_buckets=("${buckets[@]}")
            
            while [[ ${#remaining_buckets[@]} -gt 0 ]]; do
                echo "Remaining buckets: ${#remaining_buckets[@]}"
                
                local pattern
                pattern=$(prompt_user "Enter pattern to match (or 'done' to finish)" "done")
                
                if [[ "$pattern" == "done" || -z "$pattern" ]]; then
                    break
                fi
                
                # Find matching buckets
                local matching_buckets=()
                for bucket in "${remaining_buckets[@]}"; do
                    if [[ "$pattern" == "*" ]] || [[ "$bucket" == *"$pattern"* ]]; then
                        matching_buckets+=("$bucket")
                    fi
                done
                
                if [[ ${#matching_buckets[@]} -eq 0 ]]; then
                    print_warning "No buckets match pattern '$pattern'"
                    continue
                fi
                
                echo "Found ${#matching_buckets[@]} buckets matching '$pattern':"
                for bucket in "${matching_buckets[@]}"; do
                    echo "  ‚Ä¢ $bucket"
                done
                
                if prompt_yes_no "Save pattern rule for '$pattern' in '$selected_group'?" "y"; then
                    local pattern_desc="Buckets containing '$pattern' in profile '$profile'"
                    add_pattern_to_group "$selected_group" "$profile" "$pattern" "$pattern_desc"
                    print_success "‚ú® Saved pattern rule: '$pattern' ‚Üí '$selected_group'"
                    
                    # Remove matched buckets from remaining list
                    local new_remaining=()
                    for bucket in "${remaining_buckets[@]}"; do
                        local is_matched=false
                        for matched in "${matching_buckets[@]}"; do
                            if [[ "$bucket" == "$matched" ]]; then
                                is_matched=true
                                break
                            fi
                        done
                        if [[ "$is_matched" == false ]]; then
                            new_remaining+=("$bucket")
                        fi
                    done
                    remaining_buckets=("${new_remaining[@]}")
                else
                    # Just add current matching buckets
                    for bucket in "${matching_buckets[@]}"; do
                        add_bucket_to_group "$selected_group" "$profile" "$bucket"
                        echo "  ‚úì Added: $bucket"
                    done
                    
                    # Remove from remaining list
                    local new_remaining=()
                    for bucket in "${remaining_buckets[@]}"; do
                        local is_matched=false
                        for matched in "${matching_buckets[@]}"; do
                            if [[ "$bucket" == "$matched" ]]; then
                                is_matched=true
                                break
                            fi
                        done
                        if [[ "$is_matched" == false ]]; then
                            new_remaining+=("$bucket")
                        fi
                    done
                    remaining_buckets=("${new_remaining[@]}")
                fi
            done
            ;;
        3)
            # Individual selection by numbers - show only unassigned buckets
            print_info "Select specific buckets for '$selected_group'"
            echo ""
            
            # Get unassigned buckets only
            local unassigned_buckets
            mapfile -t unassigned_buckets < <(get_unassigned_buckets "$profile" "${buckets[@]}")
            
            if [[ ${#unassigned_buckets[@]} -eq 0 ]]; then
                print_info "All buckets from profile '$profile' are already assigned to groups"
                return 0
            fi
            
            echo "Unassigned buckets from profile '$profile':"
            for i in "${!unassigned_buckets[@]}"; do
                printf "  %2d. %s\n" $((i+1)) "${unassigned_buckets[$i]}"
            done
            echo ""
            echo "Enter bucket numbers (e.g., '1 5 12-15 23')"
            echo "Ranges are supported: '12-15' means buckets 12, 13, 14, 15"
            echo ""
            
            local selection
            selection=$(prompt_user "Bucket numbers" "")
            
            if [[ -n "$selection" ]]; then
                local selected_buckets=()
                
                # Parse the selection (supports ranges like 12-15)
                # For junior developers: This parsing logic handles both individual numbers and ranges
                for item in $selection; do
                    if [[ "$item" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                        # Range format: 12-15 - regex captures start and end numbers
                        local start=${BASH_REMATCH[1]}  # First captured group (start number)
                        local end=${BASH_REMATCH[2]}    # Second captured group (end number)
                        # Expand the range into individual selections
                        for ((i=start; i<=end; i++)); do
                            if [[ $i -ge 1 && $i -le ${#unassigned_buckets[@]} ]]; then
                                # Convert 1-based user input to 0-based array index
                                selected_buckets+=("${unassigned_buckets[$((i-1))]}")
                            fi
                        done
                    elif [[ "$item" =~ ^[0-9]+$ ]]; then
                        # Single number - direct selection
                        if [[ $item -ge 1 && $item -le ${#unassigned_buckets[@]} ]]; then
                            # Convert 1-based user input to 0-based array index
                            selected_buckets+=("${unassigned_buckets[$((item-1))]}")
                        fi
                    fi
                done
                
                if [[ ${#selected_buckets[@]} -gt 0 ]]; then
                    print_info "Adding ${#selected_buckets[@]} selected buckets to '$selected_group'"
                    for bucket in "${selected_buckets[@]}"; do
                        add_bucket_to_group "$selected_group" "$profile" "$bucket"
                        echo "  ‚úì Added: $bucket"
                    done
                    print_success "Added ${#selected_buckets[@]} buckets to '$selected_group'"
                else
                    print_warning "No valid bucket numbers selected"
                fi
            else
                print_info "No buckets selected"
            fi
            ;;
        *)
            print_warning "Invalid choice. No buckets added."
            ;;
    esac
}

# Creates a new group and assigns buckets to it in one workflow
# Provides options for bulk assignment, pattern rules, or individual selection
create_new_group_and_assign() {
    local profile="$1"
    shift
    local buckets=("$@")
    
    print_header "Create New Group"
    echo ""
    
    # Get new group name
    local new_group_name=""
    while [[ -z "$new_group_name" ]]; do
        new_group_name=$(prompt_user "Enter name for new group" "")
        local prompt_exit_code=$?
        
        # Check for EOF to prevent infinite loop
        if [[ $prompt_exit_code -eq 1 ]]; then
            print_error "Input stream ended. Cannot create new group without a name."
            return 1
        fi
        
        if [[ -n "$new_group_name" ]]; then
            if validate_group_name "$new_group_name"; then
                # Check if group already exists
                local existing_groups
                mapfile -t existing_groups < <(get_config_groups)
                
                local group_exists=false
                for existing in "${existing_groups[@]}"; do
                    if [[ "$existing" == "$new_group_name" ]]; then
                        group_exists=true
                        break
                    fi
                done
                
                if [[ "$group_exists" == true ]]; then
                    print_warning "Group '$new_group_name' already exists"
                    new_group_name=""
                fi
            else
                new_group_name=""
            fi
        fi
    done
    
    # Get group description
    local group_description
    group_description=$(prompt_user "Enter description for '$new_group_name'" "S3 buckets for $new_group_name")
    
    # Add the new group to config
    add_new_group_to_config "$new_group_name" "$group_description"
    
    print_success "‚úÖ Created new group: $new_group_name"
    echo ""
    
    # Now offer assignment options for this profile's buckets
    print_info "How would you like to assign buckets from profile '$profile' to group '$new_group_name'?"
    echo "  1. Use pattern-based assignment"
    echo "  2. Assign all ${#buckets[@]} buckets to '$new_group_name'"
    echo "  3. Select individual buckets"
    echo "  4. Skip assignment (just create empty group)"
    echo ""
    
    local assignment_choice
    assignment_choice=$(prompt_user "Choose assignment method (1-4)" "1")
    
    case "$assignment_choice" in
        1)
            # Pattern-based assignment
            assign_buckets_by_pattern_new_group "$new_group_name" "$profile" "${buckets[@]}"
            ;;
        2)
            # Assign all buckets
            assign_all_buckets_new_group "$new_group_name" "$profile" "${buckets[@]}"
            ;;
        3)
            # Individual selection
            assign_individual_buckets_new_group "$new_group_name" "$profile" "${buckets[@]}"
            ;;
        4)
            # Skip assignment
            print_info "Skipped bucket assignment. Group '$new_group_name' created empty."
            ;;
        *)
            print_warning "Invalid choice. Group '$new_group_name' created empty."
            ;;
    esac
    
    echo ""
    print_success "Group '$new_group_name' is ready to use!"
}

# Adds a new group to the configuration file
add_new_group_to_config() {
    local group_name="$1"
    local description="$2"
    
    # Create a temporary file to build the new config
    local temp_file
    temp_file=$(mktemp)
    
    # Use jq to add the new group
    jq --arg name "$group_name" --arg desc "$description" \
       '.groups[$name] = {"description": $desc, "buckets": [], "patterns": []}' \
       "$CONFIG_FILE" > "$temp_file"
    
    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$CONFIG_FILE"
        debug_debug "Added new group '$group_name' to configuration"
        return 0
    else
        rm -f "$temp_file"
        print_error "Failed to add new group '$group_name'"
        return 1
    fi
}

# Pattern-based bucket assignment function
# Allows user to assign buckets matching patterns to specific groups
assign_buckets_by_pattern() {
    local profile="$1"
    shift
    local buckets=("$@")
    
    print_info "Pattern-based assignment for profile '$profile'"
    echo ""
    echo "You can assign buckets to groups based on patterns (contains, starts with, ends with)."
    echo "Examples:"
    echo "  ‚Ä¢ '*' ‚Üí all buckets (wildcard)"
    echo "  ‚Ä¢ Contains '.com' ‚Üí websites group"
    echo "  ‚Ä¢ Starts with 'gypsy' ‚Üí user-files group"
    echo "  ‚Ä¢ Contains 'backup' ‚Üí backup group"
    echo ""
    
    # Get available groups
    local groups
    mapfile -t groups < <(get_config_groups)
    
    local assigned_buckets=()
    local remaining_buckets=("${buckets[@]}")
    
    # Keep asking for patterns until user is done
    while true; do
        if [[ ${#remaining_buckets[@]} -eq 0 ]]; then
            print_success "All buckets have been assigned!"
            break
        fi
        
        echo "Remaining unassigned buckets: ${#remaining_buckets[@]}"
        echo ""
        
        # Show available groups
        echo "Available groups:"
        for i in "${!groups[@]}"; do
            printf "  %d. %s\n" $((i+1)) "${groups[$i]}"
        done
        echo ""
        
        # Get pattern from user
        local pattern
        pattern=$(prompt_user "Enter pattern to match (or 'done' to finish, 'list' to see remaining buckets)" "done")
        
        case "$pattern" in
            done|Done|DONE)
                break
                ;;
            list|List|LIST)
                echo ""
                echo "Remaining buckets:"
                for i in "${!remaining_buckets[@]}"; do
                    printf "  %2d. %s\n" $((i+1)) "${remaining_buckets[$i]}"
                done
                echo ""
                continue
                ;;
        esac
        
        if [[ -z "$pattern" ]]; then
            break
        fi
        
        # Find matching buckets
        local matching_buckets=()
        for bucket in "${remaining_buckets[@]}"; do
            if [[ "$pattern" == "*" ]] || [[ "$bucket" == *"$pattern"* ]]; then
                matching_buckets+=("$bucket")
            fi
        done
        
        if [[ ${#matching_buckets[@]} -eq 0 ]]; then
            print_warning "No buckets match pattern '$pattern'"
            echo ""
            continue
        fi
        
        echo ""
        print_info "Found ${#matching_buckets[@]} buckets matching '$pattern':"
        for bucket in "${matching_buckets[@]}"; do
            echo "  ‚Ä¢ $bucket"
        done
        echo ""
        
        # Ask which group to assign them to
        local group_choice
        group_choice=$(prompt_user "Which group should these buckets be assigned to? (1-${#groups[@]}, or 's' to skip)" "s")
        
        if [[ "$group_choice" == "s" || "$group_choice" == "S" ]]; then
            print_info "Skipping pattern '$pattern'"
            echo ""
            continue
        fi
        
        if [[ "$group_choice" =~ ^[0-9]+$ ]] && [[ $group_choice -ge 1 ]] && [[ $group_choice -le ${#groups[@]} ]]; then
            local selected_group="${groups[$((group_choice-1))]}"
            
            # Ask if they want to save the pattern or just add current buckets
            echo ""
            print_info "Assignment options for pattern '$pattern':"
            echo "  1. Save pattern rule (future buckets matching '$pattern' will auto-assign)"
            echo "  2. Add current matching buckets only"
            echo ""
            
            local assignment_choice
            assignment_choice=$(prompt_user "Choose assignment method (1-2)" "1")
            
            case "$assignment_choice" in
                1)
                    # Save pattern rule
                    local pattern_desc="Buckets containing '$pattern' in profile '$profile'"
                    if add_pattern_to_group "$selected_group" "$profile" "$pattern" "$pattern_desc"; then
                        print_success "‚ú® Saved pattern rule: '$pattern' ‚Üí '$selected_group' (profile: $profile)"
                        print_info "Future buckets matching this pattern will automatically be included!"
                        
                        # Still assign current matching buckets for immediate use
                        local assigned_count=0
                        for bucket in "${matching_buckets[@]}"; do
                            assigned_buckets+=("$bucket")
                            ((assigned_count++))
                        done
                        
                        # Remove from remaining list
                        local new_remaining=()
                        for bucket in "${remaining_buckets[@]}"; do
                            local is_assigned=false
                            for assigned in "${matching_buckets[@]}"; do
                                if [[ "$bucket" == "$assigned" ]]; then
                                    is_assigned=true
                                    break
                                fi
                            done
                            if [[ "$is_assigned" == false ]]; then
                                new_remaining+=("$bucket")
                            fi
                        done
                        remaining_buckets=("${new_remaining[@]}")
                        
                        print_info "Current matching buckets will be mounted via pattern rule"
                    else
                        print_error "Failed to save pattern rule"
                    fi
                    ;;
                2)
                    # Add individual buckets
                    print_info "Adding ${#matching_buckets[@]} individual buckets to group '$selected_group'"
                    
                    local assigned_count=0
                    for bucket in "${matching_buckets[@]}"; do
                        add_bucket_to_group "$selected_group" "$profile" "$bucket"
                        echo "  ‚úì Added: $bucket"
                        assigned_buckets+=("$bucket")
                        ((assigned_count++))
                    done
                    
                    # Remove assigned buckets from remaining list
                    local new_remaining=()
                    for bucket in "${remaining_buckets[@]}"; do
                        local is_assigned=false
                        for assigned in "${matching_buckets[@]}"; do
                            if [[ "$bucket" == "$assigned" ]]; then
                                is_assigned=true
                                break
                            fi
                        done
                        if [[ "$is_assigned" == false ]]; then
                            new_remaining+=("$bucket")
                        fi
                    done
                    remaining_buckets=("${new_remaining[@]}")
                    
                    print_success "Assigned $assigned_count individual buckets to group '$selected_group'"
                    ;;
                *)
                    print_warning "Invalid assignment choice. Skipping pattern '$pattern'"
                    ;;
            esac
        else
            print_warning "Invalid group choice"
        fi
        echo ""
    done
    
    if [[ ${#remaining_buckets[@]} -gt 0 ]]; then
        print_info "Remaining ${#remaining_buckets[@]} unassigned buckets:"
        for bucket in "${remaining_buckets[@]}"; do
            echo "  ‚Ä¢ $bucket"
        done
        echo ""
        
        if prompt_yes_no "Would you like to assign remaining buckets individually?" "n"; then
            assign_individual_buckets "$profile" "${remaining_buckets[@]}"
        fi
    fi
}

# Helper function for per-bucket assignment to groups
# Prompts user for each bucket individually with group selection
assign_individual_buckets() {
    local profile="$1"
    shift
    local buckets=("$@")
    
    print_info "Individual bucket selection for profile '$profile'"
    echo ""
    
    for bucket in "${buckets[@]}"; do
        echo "Bucket: $bucket"
        echo "Which group should this bucket be assigned to?"
        
        local groups
        mapfile -t groups < <(get_config_groups)
        
        for i in "${!groups[@]}"; do
            printf "  %d. %s\n" $((i+1)) "${groups[$i]}"
        done
        echo "  s. Skip this bucket"
        echo ""
        
        local choice
        choice=$(prompt_user "Choose group (1-${#groups[@]}, s)" "s")
        
        case "$choice" in
            s|S|skip|Skip)
                print_info "Skipping bucket '$bucket'"
                ;;
            [1-9]*)
                if [[ "$choice" -ge 1 && "$choice" -le ${#groups[@]} ]]; then
                    local selected_group="${groups[$((choice-1))]}"
                    add_bucket_to_group "$selected_group" "$profile" "$bucket"
                    print_success "Added '$bucket' to group '$selected_group'"
                else
                    print_warning "Invalid choice. Skipping bucket '$bucket'"
                fi
                ;;
            *)
                print_warning "Invalid choice. Skipping bucket '$bucket'"
                ;;
        esac
        echo ""
    done
}

# Adds a single bucket to a group in the JSON configuration using jq
# Updates the config file with proper profile:bucket structure
add_bucket_to_group() {
    local group="$1"
    local profile="$2"
    local bucket="$3"
    
    # Create a temporary file to build the new config
    local temp_file
    temp_file=$(mktemp)
    
    # Use jq to add the bucket to the specified group
    jq --arg group "$group" --arg profile "$profile" --arg bucket "$bucket" \
       '.groups[$group].buckets += [{"profile": $profile, "bucket": $bucket}]' \
       "$CONFIG_FILE" > "$temp_file"
    
    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$CONFIG_FILE"
        debug_debug "Added bucket '$bucket' (profile: $profile) to group '$group'"
    else
        rm -f "$temp_file"
        print_error "Failed to add bucket '$bucket' to group '$group'"
        return 1
    fi
}

# Adds a pattern rule to a group in the JSON configuration using jq
# Patterns enable dynamic bucket matching for future buckets
add_pattern_to_group() {
    local group="$1"
    local profile="$2"
    local pattern="$3"
    local description="$4"
    
    # Create a temporary file to build the new config
    local temp_file
    temp_file=$(mktemp)
    
    # Use jq to add the pattern to the specified group
    jq --arg group "$group" --arg profile "$profile" --arg pattern "$pattern" --arg desc "$description" \
       '.groups[$group].patterns += [{"profile": $profile, "pattern": $pattern, "description": $desc}]' \
       "$CONFIG_FILE" > "$temp_file"
    
    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$CONFIG_FILE"
        debug_debug "Added pattern '$pattern' (profile: $profile) to group '$group'"
        return 0
    else
        rm -f "$temp_file"
        print_error "Failed to add pattern '$pattern' to group '$group'"
        return 1
    fi
}

main "$@"